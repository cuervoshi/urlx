import type { Response } from 'express';

import type { ExtendedRequest } from '@type/request';
import { Debugger } from 'debug';
import { logger, requiredEnvVar, shuffled } from '@lib/utils';
import redis from '@services/redis';
import { commandOptions } from 'redis';
import { nip57 } from 'nostr-tools';
import { connectToTempRelays, getSignerNDK } from '@services/ndk';
import { OutboxService } from '@services/outbox';
import { lnInboundTx } from '@lib/events';

const log: Debugger = logger.extend('rest:invoice:settlement:post');
const warn: Debugger = log.extend('warn');
const error: Debugger = log.extend('error');
const debug: Debugger = log.extend('debug');

const handler = async (req: ExtendedRequest, res: Response) => {
  const invoice = req.body;
  // Publish inbound-tx if an invoice generated by us is settled
  if (invoice.state === 'SETTLED') {
    log('Received settled invoice');
    debug('Received invoice: %O', invoice);
    const [pubkey, zapRequest] = await redis.hmGet(
      commandOptions({ returnBuffers: false }),
      invoice.r_hash,
      ['pubkey', 'zapRequest'],
    );
    if (!pubkey) {
      log('Invoice not generated by us');
      res.status(404).send();
    }
    if (zapRequest) {
      const zapReceipt = nip57.makeZapReceipt({
        zapRequest,
        preimage: invoice.r_preimage.toString('hex'),
        bolt11: invoice.payment_request,
        paidAt: new Date(),
      });
      const defaultWriteRelay: string = requiredEnvVar('NOSTR_WRITE_RELAY')
        .trim()
        .toLowerCase();
      const relayUrls = shuffled<string>(
        JSON.parse(zapRequest)
          .tags.find((t: string[]) => 'relays' === t[0])
          .slice(1)
          .map((r: string) => {
            return r.trim();
          })
          .filter((r: string) => {
            return r.toLowerCase() !== defaultWriteRelay;
          }),
      ).slice(-5);
      const ndk = getSignerNDK();
      const relaySet = connectToTempRelays(relayUrls, ndk);
      new OutboxService(ndk)
        .publish(zapReceipt, relaySet)
        .catch((e) => warn('Could not publish zapReceipt to external: %O', e));
      req.context.outbox.publish(zapReceipt).catch((e) => {
        error('Could not publish zapReceipt to internal: %O', e);
      });
    }
    req.context.outbox
      .publish(
        lnInboundTx(invoice.amt_paid_msat, invoice.payment_request, pubkey),
      )
      .then(async () => {
        await redis.del(invoice.r_hash);
        res.status(204).send();
      })
      .catch((e) => {
        error('Could not publish inboundTx: %O', e);
        res.status(500).send();
      });
  } else {
    res.status(400).send();
  }
};

export default handler;
