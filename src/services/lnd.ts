import LndGrpc from 'lnd-grpc';
import { AddInvoiceResponse, ILndGrpc } from '@type/lnd-grpc';
import { logger, requiredEnvVar, shuffled } from '@lib/utils';
import { Debugger } from 'debug';
import redis from '@services/redis';
import { lnInboundTx } from '@lib/events';
import { Outbox, OutboxService } from '@services/outbox';
import { connectToTempRelays, getSignerNDK, getWriteNDK } from '@services/ndk';
import { commandOptions } from 'redis';
import { nip57 } from 'nostr-tools';

const log: Debugger = logger.extend('services:lnd');
const warn: Debugger = log.extend('warn');
const error: Debugger = log.extend('error');

/**
 * Handles communication with LND.
 *
 * Responsible for keeping the gRPC connection with LND and makes
 * available methods for generating and paying invoices. Also includes
 * the subscriptions to received payments.
 */
class LndService {
  private grpc: ILndGrpc;

  /**
   * Starts connection ups and sets subscriptions up.
   */
  constructor(private readonly outbox: Outbox) {
    this.grpc = new LndGrpc({
      lndconnectUri: requiredEnvVar('LNDCONNECT_URI'),
    });
    this.connect().then(() => this.setUpSubscriptions());
  }

  async generateInvoice(amount: bigint): Promise<AddInvoiceResponse> {
    await this.grpc.waitForState('active');
    const { Lightning } = this.grpc.services;
    return Lightning.addInvoice({
      value_msat: amount.toString(),
    });
  }

  /**
   * Pays a given lightning invoice
   *
   * Tries to pay an invoice, return a void promise that resolves on
   * success and fails otherwise with reason.
   */
  async payInvoice(invoice: string): Promise<void> {
    await this.grpc.waitForState('active');
    const { Router } = this.grpc.services;
    const call = Router.sendPaymentV2({
      payment_request: invoice,
      timeout_seconds: 5,
      no_inflight_updates: true,
      fee_limit_msat: 1001,
      allow_self_payment: true,
    });
    return new Promise<void>((resolve, reject) => {
      call.on('data', (res: any) => {
        if ('SUCCEEDED' === res.status) {
          resolve();
        } else {
          reject(res.failure_reason);
        }
      });
      call.on('error', (e: Error) => reject(e));
    });
  }

  /**
   * Connects to LND through gRPC
   *
   * Throws on errors.
   */
  private async connect() {
    log('before connect, state: %s', this.grpc.state);
    await this.grpc.connect().catch((e) => {
      error('Unexpected error connecting: %O', e);
      throw e;
    });
    log('after connect, state: %s', this.grpc.state);
    this.grpc.on('locked', () => log('wallet locked!'));
    this.grpc.on('active', () => log('wallet unlocked!'));
    this.grpc.on('disconnected', () => warn('Disconnected from lnd'));
    this.grpc.on('error', (e: Error) => {
      error('Unexpected error: %O', e);
      throw e;
    });
  }

  /**
   * Subscribes to any settled invoice.
   */
  private async setUpSubscriptions() {
    const { Lightning } = this.grpc.services;
    const call = Lightning.subscribeInvoices({
      add_index: Infinity,
      settle_index: 0,
    });
    call.on('data', async (res: any) => {
      // Publish inbound-tx if an invoice generated by us is settled
      if (res.state === 'SETTLED') {
        log('Received settled invoice');
        const [pubkey, zapRequest] = await redis.hmGet(
          commandOptions({ returnBuffers: false }),
          res.r_hash,
          ['pubkey', 'zapRequest'],
        );
        if (pubkey) {
          if (zapRequest) {
            const zapReceipt = nip57.makeZapReceipt({
              zapRequest,
              preimage: res.r_preimage.toString('hex'),
              bolt11: res.payment_request,
              paidAt: new Date(),
            });
            const defaultWriteRelay: string = requiredEnvVar(
              'NOSTR_WRITE_RELAY',
            )
              .trim()
              .toLowerCase();
            const relayUrls = shuffled<string>(
              JSON.parse(zapRequest)
                .tags.find((t: string[]) => 'relays' === t[0])
                .slice(1)
                .map((r: string) => {
                  return r.trim();
                })
                .filter((r: string) => {
                  return r.toLowerCase() !== defaultWriteRelay;
                }),
            ).slice(-5);
            const ndk = getSignerNDK();
            const relaySet = connectToTempRelays(relayUrls, ndk);
            new OutboxService(ndk)
              .publish(zapReceipt, relaySet)
              .catch((e) =>
                warn('Could not publish zapReceipt to external: %O', e),
              );
            this.outbox.publish(zapReceipt).catch((e) => {
              error('Could not publish zapReceipt to internal: %O', e);
            });
          }
          this.outbox
            .publish(
              lnInboundTx(res.amt_paid_msat, res.payment_request, pubkey),
            )
            .then(() => redis.del(res.r_hash))
            .catch((e) => error('Could not publish inboundTx: %O', e));
        }
      }
    });
  }
}

const lnd = new LndService(new OutboxService(getWriteNDK()));

export default lnd;
