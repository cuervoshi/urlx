import { Debugger } from 'debug';

import type { NDKEvent, NDKFilter, NostrEvent } from '@nostr-dev-kit/ndk';

import { Kind, internalTx } from '@lib/events';
import { logger, nowInSeconds, requiredEnvVar } from '@lib/utils';

import redis from '@services/redis';
import { Context } from '@type/request';
import { getReadNDK } from '@services/ndk';
import { createHash } from 'crypto';
import { commandOptions } from 'redis';

const log: Debugger = logger.extend('nostr:inboundTransaction');

const debug: Debugger = log.extend('debug');
const warn: Debugger = log.extend('warn');
const error: Debugger = log.extend('error');

const filter: NDKFilter = {
  kinds: [Kind.REGULAR.valueOf()],
  authors: [requiredEnvVar('LEDGER_PUBLIC_KEY')],
  '#p': [requiredEnvVar('NOSTR_PUBLIC_KEY')],
  '#t': ['inbound-transaction-ok'],
  since: nowInSeconds() - 86000,
};

/**
 * Extract value of the "p" tags
 */
function extractPTagValues(event: NostrEvent): string[] {
  try {
    return event.tags.filter((t) => 'p' === t[0]).map((t) => t[1]);
  } catch {
    /* ... */
  }
  return [];
}

/**
 * Extract value of first "e" tag, or null if none found
 */
function extractFirstE(event: NostrEvent): string | null {
  try {
    return event.tags.filter((t) => 'e' === t[0])[0][1];
  } catch {
    /* ... */
  }
  return null;
}

/**
 * Extract value of first "bolt11" tag, or null if none found
 */
function extractBolt11(event: NDKEvent): string | null {
  const bolt11 = event.tags.find((t) => 'bolt11' === t[0]);
  if (undefined !== bolt11) {
    return bolt11[1];
  }
  return null;
}

/**
 * Mark the given event id as handled in Redis
 */
async function markHandled(eventId: string) {
  redis.hSet(eventId, 'handled', 'true');
}

/**
 * Return the internal-transaction-ok handler
 */
const getHandler = (ctx: Context): ((event: NostrEvent) => Promise<void>) => {
  /**
   * Handle internal-transaction-ok
   *
   * If the internal transaction ok is one not generated by us and not
   * previously handled, get invoice and try to pay it. Publish an
   * outbound transaction on success or a revert transaction on error.
   */
  return async (event: NostrEvent) => {
    if (event.id === undefined) {
      throw new Error('Received event without id from relay');
    }

    const eventId: string = event.id;

    if ((await redis.hGet(eventId, 'handled')) === 'true') {
      debug('Already handled event %s', eventId);
      return;
    }

    const [target, receiver] = extractPTagValues(event);
    const startEventId = extractFirstE(event);

    if (!target) {
      warn('No target found');
    }
    if (!receiver) {
      warn('No target found');
    }
    if (!startEventId) {
      warn('No starting event found');
    }
    if (!target || !receiver || !startEventId) {
      await markHandled(eventId);
      return;
    }

    // only handle events originated by me and I am the receiver
    if (requiredEnvVar('NOSTR_PUBLIC_KEY') !== target || target !== receiver) {
      await markHandled(eventId);
      return;
    }

    const startEvent = await getReadNDK().fetchEvent(startEventId);

    debug('start event: %O', startEvent);

    if (startEvent === null) {
      warn('Did not find inboundTx start for ok');
      await markHandled(eventId);
      return;
    }

    const bolt11 = extractBolt11(startEvent);

    if (null === bolt11) {
      error('Received inbound tx without invoice');
      await markHandled(eventId);
      return;
    }

    const prHash: string = createHash('sha256').update(bolt11).digest('hex');
    const pubkey = await redis.hGet(
      commandOptions({ returnBuffers: false }),
      prHash,
      'pubkey',
    );

    if (!pubkey) {
      error('Did not find public key for received inbound');
      await markHandled(eventId);
      return;
    }

    ctx.outbox
      .publish(internalTx(pubkey, startEvent.content, startEventId))
      .then(() => {
        log('Sucessfully published transaction');
      })
      .catch((e) => {
        error('Unexpected error when publishing transaction: %O', e);
      });
    await markHandled(eventId);
  };
};

export { filter, getHandler };